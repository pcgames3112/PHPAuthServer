<?php namespace client;

use AuthAppModel;
use BaseController;
use spitfire\exceptions\HTTPMethodException;
use spitfire\exceptions\PublicException;
use defer\incinerate\CredentialTask as IncinerateCredential;
use function db;

/* 
 * The MIT License
 *
 * Copyright 2021 César de la Cal Bretschneider <cesar@magic3w.com>.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * The credential controller allows an authorized party to create and revoke client
 * secrets. Credentials are usually not expired immediately, but given a grace
 * period to ease the transition.
 * 
 * You can also define credentials to be expired regularly, so applications are
 * required to renew them in certain intervals.
 * 
 * @author César de la Cal Bretschneider <cesar@magic3w.com>
 */
class CredentialController extends BaseController
{
	
	/**
	 * Creates a new credential for the application, this secret can then be used
	 * to authenticate the application against PHPAS and applications that depend
	 * on it.
	 * 
	 * @param AuthAppModel $client
	 */
	public function create(AuthAppModel $client) 
	{
		#TODO: When generating a template it should offer expirations like 3 months or 2 years (or unlimited)
		
		if ($this->user->_id !== $client->owner->_id) {
			throw new PublicException('Not permitted', 403);
		} 
		
		$credential = db()->table('client\credential')->newRecord();
		$credential->client = $client;
		$credential->store();
		
		$this->view->set('credential', $credential);
	}
	
	/**
	 * Revokes a client credential. This credential can then no longer be used by
	 * the application to generate tokens or access any resources.
	 * 
	 * Note: This endpoint does not revoke the tokens generated by the application.
	 * If the application was compromised, tokens need to be revoked explicitly.
	 * 
	 * @param CredentialModel $credential
	 */
	public function revoke(CredentialModel $credential) 
	{
		#When generating a template it should offer expirations like a few hours, or a few days
		
		if ($this->user->_id !== $credential->client->owner->_id) {
			throw new PublicException('Not permitted', 403);
		} 
		
		try {
			if (!$this->request->isPost()) { throw new HTTPMethodException(); }
			
			# Calculate the expiration, it may not be negative, nor longer than two years
			$expires = within(0, $_POST['expires']?? 0, 365 * 86400 * 2);
			
			# Write the expiration time to the credential
			$credential->expires = time() + $expires;
			$credential->store();
			
			# Create a task to incinerate the credential
			async()->defer(IncinerateCredential::class, $credential->_id, $credential->expires);
			
			#Write it to the view
			$this->view->set('expired', true);
		} 
		catch (HTTPMethodException $ex) {

		}
		
		$this->view->set('credential', $credential);
	}
	
}
